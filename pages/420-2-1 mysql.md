- 页
	- 查询id=4的一条记录，这条记录可能才30byte，但是现在返回的最小单位是一页，16kb，这时候id=5-7的大概率都在返回的这一页当中的， 这样一次io就能解决问题。就是避免一条一条磁盘数据
	- 有很多种不同类型的页
		- 存放表空间头部信息的页
		- 存放undo日志信息的页
		- 存放表中数据记录的页  索引页或者数据页   innodb 索引就是数据，数据就是索引
		- ![image.png](../assets/image_1717338611029_0.png)
			- file header 存储页的通用信息
			- page header 存储数据页专用的信息
			- infimum + supermum 正无穷和负无穷 这个和页种具体的记录毫无关系，只是单独拉出来记录的，每个页里都是这两个值
			- 存储页种记录的相对位置，这样就能快速进行定位
	- ![image.png](../assets/image_1717340703412_0.png)
	  id:: 665c8a1d-24cf-4aa0-9836-a91a802d4cc4
	- 分为记录额外信息和真实数据
		- 额外信息
			- 逻辑删除标记，当删除了之后，其实不会立马清空，会记录到删除记录的一个链表中，其他要新插入或修改的记录可以放到这条记录的位置上，不需要重新开辟空间（但是按照id分配的话，不就会有跨页的问题？？？
			- min_rec_flag 后续会将
			- n_owned 后续会讲，分成多组之后，如果你是这个组里id最大的，就会在这里保存这个组里的记录的条数
			- heap_no 相对位置
			- record_type记录类型，普通的就是0， 如果是b+树非叶子节点的目录项记录是1， 2是最小值，3是最大值
			- next_record 会有逻辑顺序，比如1后面是2，2后面是3，链表存储，会记录到下一个逻辑位置的距离，可能有正有负。物理位置是随机的，逻辑位置就是靠这个next_record来维护的
		- 真实数据
			- 各个列的值
			- row_id 排序的时候先依靠主键，如果没有主键，去找不重复且不为空的，还没有，会有个row_id来标注顺序
			- trx_id 事务的id，版本控制
			- roll_pinter，如果对一条记录多次修改，就是有版本4指向版本3指向版本2指向版本1的这个
-