tags:: 消息队列，内存溢出，垃圾回收

- 自动内存管理机制实现原理
	- 申请内存
		- 计算要创建对象需要占用的内存大小
		- 在内存中找一块儿连续并且是空闲的内存空间，标记为已占用；
		- 把申请的内存地址绑定到对象的引用上，这时候对象就可以使用了。
	- 内存回收
		- 找出所有可以回收的对象，将对应的内存标记为空闲
		- 整理内存碎片
		- 标记-清除算法
			- 标记阶段：从 GC Root 开始，你可以简单地把 GC Root 理解为程序入口的那个对象， 标记所有可达的对象，因为程序中所有在用的对象一定都会被这个 GC Root 对象直接或 者间接引用。
			- 清除阶段：遍历所有对象，找出所有没有标记的对象。这些没有标记的对象都是可以被回 收的，清除这些对象，释放对应的内存即可。
			- 但是在标记和清除阶段，要讲进程暂停，否则结果不准确。这个就会导致卡死等情况。
		- 内存清理
			- 将不连续的空闲内存移动到一起，空出足够的连续内存空间供后续使用。
			- 整理过程中需要移动内存中的数据，不可避免的要暂停进程。如果暂停时间过长，程序看起来就像卡死了一样
- 为什么在高并发下程序会卡死
	- 微服务收到请求后，执行业务逻辑返回响应，会创建一些对象，这个请求响应结束了，创建的对象没用了，会在下次垃圾回收中被释放。
	- 地并发情况，创建对象不多，会选择系统不忙的时候执行垃圾回收，暂停时间也短，我们无法感知
	- 高并发情况下，迅速占满内存，没内存用了，垃圾回收被迫启动，而且回收的是占满整个内存的海量对象，执行时间长。进程长时间暂停，会导致大量请求积压等待，垃圾回收刚结束，请求又进来，迅速占满内存。
	- 如果垃圾回收速度跟不上创建对象速度，会产生内存溢出现象
- 高并发下的内存管理技巧
	- 处理大量请求的同时，尽量少的产生一次性对象。优化你的代码中处理请求的业务逻辑，尽量少的创建一次性对象，特别 是占用内存较大的对象。
	- 对于需要频繁使用，占用内存大的一次性对象，考虑自行回收并重用这些对象。
		- 为对象建立对象池，收到请求后，在对象池内申请一个对象，使用完放回对象池中。
	- 使用更大内存服务器。