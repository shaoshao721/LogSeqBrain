tags:: seata， TCC模式

- 不依赖资源管理器对XA协议的支持，通过对业务逻辑的调度来实现分布式事务
- TCC模式和AT模式的对比
	- seata本质上来说，是一个两阶段提交模型。全局事务是由一个个分布式事务组成的。同时，分布式事务都要满足两阶段提交的模型。需要分布式事务，先有一阶段prepare行为，然后二阶段进行统一的提交或回滚操作
	- 因为TCC和AT都遵循两阶段提交的模型，所以两个模型可以同时存在于一个分布式的事务中。区别只是，是自动实现prepare，rollback，commit还是通过自定义来进行实现。
	- AT模式，prepare自动完成准备动作。commit，框架帮助清理事务日志。rollback，自动完成数据回滚。
	- 区别
		- 在AT模式中。每个数据库都是一个资源。
			- prepare，在业务通过JDBC标准接口访问数据库资源时，seata会对所有请求进行拦截。除了完成原始请求外，还额外进行了一些与分布式事务相关的操作。每个本地事务提交前，RM都会向TC注册一个分支事务，并在提交本地事务后上报分支事务状态到TC。整个请求链路调用完成后，TM通知TC提交或回滚全局事务，进入二阶段调用流程。TC会根据之前注册的分支事务回调对应的RM去执行对应资源的二阶段commit或rollback处理
			- commit，根据分支事务ID找到对应事务日志将其删除
			- rollback，根据分支事务ID找到事务日志，在数据校验成功之后，根据事务日志构建回滚语句完成二阶段回滚
		- TCC模式，将TCC服务接口当成资源
			- prepare阶段，将调用TCC服务接口中的try方法的时候，seata进行拦截，RM向TC注册分支，完成try方法的逻辑，完成后上报分支事务状态到TC，请求链路调用完成后，通过TC提交或回滚全局事务，进入二阶段调用流程。TC通过分支事务的资源ID回调响应的RM执行commit或rollback操作
			- commit，调用接口的commit方法
			- rollback，调用接口的cancel方法
- TCC模式的设计方法
	- 对于业务系统重的一个特定的业务逻辑，对外提供服务有一定的不确定性，对业务逻辑尝试方法的调用只是一个临时性的操作，主业务服务认为全局事务应该提交的时候，就confirm方法，将其变成确定操作。反之，要求取消之前的临时操作，对应cancel
	- 两种实现模式
		- 资源预留模式
			- 先将资源进行预留，保证二阶段一定能执行下去。比如银行扣款，先将钱预留出来，别的事务不能用。二阶段要提交的时候，把钱真的扣掉，要回滚的时候，把钱解冻，还回来
			- try 完成所有的业务检查，将资源预留出来
			- confirm 基于try方法预留的资源，完成真正的业务逻辑。如果confirm失败，则一直重试，最终一定会成功。要保证confirm有幂等性
			- cancel 释放预留的资源，cancel失败，也一直重试，最后一定会成功，要保证cancel有幂等性
		- 补偿模式
			- 用的更多
			- 先直接提交了，额外记录一些信息，confirm的话，就把额外信息删了。cancel的话，根据额外信息，进行回滚操作。比如下订单，减库存操作。一阶段，订单insert一条，减少库存，记录库存减少的量。confirm的话，删除额外的记录信息。cancel的话，把订单表的那条记录删了，把库存加回来，记录的额外信息删了。（其实有点类似at模式
			-
			-
			-