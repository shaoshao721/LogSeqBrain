tags:: 消息队列，缓存策略，磁盘IO

- 为啥用磁盘
	- 持久化存储，即使断电，数据也还存在着。
	- 便宜，低成本能存储海量消息
	- 缺点
		- 读写速度慢，SSD 每秒钟读写几千次。如果每次请求要读写3-5次，那每秒才能处理1000次左右请求
		- 内存的随机读写速度是磁盘的10万倍。内存作为缓存加速应用访问速度。
- 使用缓存最佳实践
	- 选择只读缓存还是读写缓存
		- 区别：更新数据的时候，是否经过缓存。
		- pageCache就是读写缓存。写文件的时候，数据先写到缓存。写完了就结束，操作系统异步的把数据更新到磁盘文件里。读文件的时候，先从pageCache读，找不到的话产生缺页中断，将文件读取到pageCache里，再返回给应用程序。
			- 操作系统可以保证，异常退出的时候，还是能把pageCache的内容同步到磁盘，但是要是断电了，就不行了
			- 不太可靠，牺牲数据一致性换取性能
			- 实现复杂，操作系统要记录数据又哪些变化，在另外一个线程，要把变化的数据更新到磁盘里。在提供并发读写的同时来异步更新数据，这个过程中要保证数据的一致性，并且有非 常好的性能，实现这些真不是一件容易的事儿。
			- 不推荐用读写缓存
				- 那为啥kafka用pageCache提升性能呢?
					- 消息队列读写比例大概是1：1.只读缓存提升效果不大
					- 不止靠磁盘保证数据可靠性，更依赖不同节点上的多副本，不会丢消息
					- pageCache不是kafka实现的，是操作系统实现的，不涉及复杂问题
			- 大部分消息队列也用读写缓存加速消息写入，只是实现方式不一样
	- 构建只读缓存要考虑的问题
		- 数据要更新的时候，磁盘里的数据和缓存的副本都需要进行更新
		- 并发的时候可能会有并发操作
			- 简单的方法，定时将磁盘上的数据同步到缓存上。一般都是全量更新，但是如果缓存的数据太大，也可以选择增量更新
			- 不去更新缓存中的数据，而是给缓存中的每条数据设置较短过期时间，过期之后需要再从磁盘上加载这条数据，变相实现了数据更新
			- 适用于对数据的一致性不敏感的业务。
- 缓存置换策略
	- 优先缓存哪些数据能让缓存的命中率最高
	- 如果这些数据不在缓存 中，那只能去磁盘中访问数据，就会比较慢。这种情况我们称为“缓存穿透”
	- 如果可以预测未来访问哪些数据。就要访问啥就缓存啥
	- LRU
	- JMQ 根据消息这种流数据存储的特点，在淘汰时增加了一个考量维度： 页面位置与尾部的距离。因为越是靠近尾部的数据，被访问的概率越大。
		- 综合考虑下的淘汰算法，不仅命中率更高，还能有效地避免“挖坟”问题：例如某个客 户端正在从很旧的位置开始向后读取一批历史数据，内存中的缓存很快都会被替换成这些历 史数据，相当于大部分缓存资源都被消耗掉了，这样会导致其他客户端的访问命中率下降。 加入位置权重后，比较旧的页面会很快被淘汰掉，减少“挖坟”对系统的影响。