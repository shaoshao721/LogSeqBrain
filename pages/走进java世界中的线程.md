tags:: 多线程编程

- 进程、线程与任务
	- 进程：一个运行的程序实例。程序是静态的，platfrom代码就是程序。但是运行起来的，就是一个进程实例，idea应用就是一个进程。但是web应用除外，java web服务器是个进程，可以运行多个java web应用
	- 进程是资源分配的最小单位
	- 线程是进程中可以独立执行的最小单位
	- 任务：要完成的计算任务，下载文件之类的
-
- 多线程编程简介
	- 一个线程就是一个对象
	- 为啥要用线程，比如说有其中的一个步骤特别耗时，就可以单独用线程去处理，不要让它成为卡点
	- 异步，并发
-
- java线程API简介
	- 线程的创建，启动与运行
		- new 一个thread的子类    new Thread(new 一个实现了Runnable的接口)
		- 一次性用品，如果再调用start接口会报错
		- 如果直接调用run方法，是主线程来执行的
	- 线程属性
		- 编号 tid，在不同的进程里不唯一，之前的线程结束了，这个编号页可能被分配给别人，所以不要把这个id作为一个唯一的属性，放在数据库之类的地方
		- 名称 不唯一，可以重复
		- 线程类别：守护线程，非守护线程。如果是非守护线程，程序会等到他们都执行完了才会退出。默认会继承父类的线程类别
		- 优先级，默认是5，默认继承父类的线程类别，但是只是参考
	- Thread 类常用方法
		- currentThread 获取当前执行的线程信息
		- start 开启线程
		- run 实现处理逻辑，一般不是自己显示调用的，而是由jvm调用
		- join A调用B的join方法，会去执行b，b执行完了，再回来执行A
		- yield 表示可以让出自己的运行权，实际能不能让出去不一定
		- sleep 休眠一定时间
- 无处不在的线程
	- 垃圾回收器
	- JIT编译器等等
- 线程的层次关系
	- 从谁的运行代码里创建出来的，都是这个线程的子线程
	- 不能通过子线程获取父线程，也不能通过父线程获取子线程
	- 生命周期没有必然联系
- 生命周期状态
	- NEW 只能有一次，被NEW出来就是这个状态
	- 通过start方法会到RUNNABLE状态，如果有所有的资源，但是时间片没流转到就是 READY，时间片也流转到了就是RUNNING
	- 如果没有资源，发起了阻塞式IO操作，申请锁 都会进入 BLOCKED
	- 如果调用了wait，join，park方法会到waiting。调用nofity notifyall，unpark，join的那个线程结束了之后，会回到RUNNABLE
	- 如果调用了sleep(long),wait(long) park带时间的话，会到 TIMED_WAITING
- 线程监视
	- THREAD DUMP，会包括线程的属性，生命周期的状态，调用栈
- 多线程编程的优势和风险
	- 优势
		- 提高系统吞吐率
		- 提高响应
		- 充分利用多核处理器的资源
		- 最小化对系统资源的使用
		- 简化程序的结构
	- 风险
		- 线程安全
		- 线程活性 死锁
		- 上下文切换带来的资源消耗
		- 可靠性