tags:: 多线程编程

- 串行，并发与并行
	- 串行 一个线程，任务完成了才能开始进行下一个任务
	- 并发 一个线程，但是可以同时进行多个任务，通过时间片切换的方式
	- 并行 有多个线程，同时投入，一般来说的话会对应多个处理器
- 竞态
	- 计算结果的正确性和时间有关系
	- 一般是由于读取了脏数据，读取到了一个过时的数据，丢失了更新导致的
	- 多线程环境下，由于有共享变量，多个线程都可以读写这个变量，导致不同执行过程中，执行的顺序不同，导致正确性无法保证
	- 状态变量：类的实例变量，静态变量
	- 共享变量：能被多个线程共同访问的变量
	- 竞态模式
		- read modify write
			- 先读，然后修改，把修改的数据写入进去
			- 修改了但是还没有写进去，其他一个线程过来了，读取了修改之前的数据，就会导致线程1的修改丢失
		- check then act
			- 先执行if语句，然后执行if条件里的语句
	- 竞态产生的条件
		- 两个线程并发访问一个共享变量，且两个线程的操作不都是读操作的时候，就可能会产生静态
		- 消除的情况
			- 不是访问的共享变量，是局部变量
			- 通过使用synchronized关键字，不要让多个线程同时访问
- 线程安全问题由三个方面 原子性，可见性，有序性
- 原子性
	- 对共享变量的操作从执行线程意外的任何线程来看，要不然是还没有开始要么是已经结束了，感知不到其中间状态。 访问同一组共享变量的原子操作是不能够被交错的
	- 原子操作只有在多线程环境下的共享变量才有这个概念，其他无所谓的
	- 实现原子性
		- 用锁，同一时刻只有一个线程操作，不会被打断。同一个共享变量在任意时刻只能被同一个线程访问
		- CAS，在硬件层面实现，硬件锁
	- java中，除了long和double以外的变量的写操作都是原子操作，基本类型+引用类型
	- volatile关键字修饰的话，long和double也是有原子性的
	- 原子操作+原子操作不一定是原子操作
- 可见性
	- 一个线程对共享变量的更新的结果对于读取对应的共享变量的线程是否可见
	- 举个例子，有的时候JIT编译器觉得这个代码只有一个线程对其方法对其访问，会进行优化，导致错误
	- 可见性其实是因为，不同的处理器并不是直接和主内存打交道的，通过寄存器，高速缓存，写缓冲器，无效化队列等部件执行内存的读写操作的，所以很容易就读到一个旧值
	- 可以通过缓存一致性协议来解决
		- 写的时候，要求更新必须写到处理器的高速缓存或主内存中，冲刷处理器
		- 读的时候，如果这个共享变量已经被别的处理器更新了，那必须从那个处理器的高速缓存或主内存中进行缓存同步  刷新处理器缓存
		- 高速缓存和主内存是可以同步的
	- 保证可见性
		- volatile
			- 提示JIT编译器，这个变量是能被多个线程共享的，让他不要进行不正常的优化
			- 读取一个volatile变量的时候，会执行刷新处理器缓存的操作。读取一个volatile变量的时候，会执行冲刷处理器缓存的操作
	- 对于共享变量，一个线程更新了他，能保证可见性，其他线程能读到这个更新后的值，这个值被称为这个变量的相对新值。  如果要求读取到这个共享变量的线程在读取并使用这个变量的时候，其他线程也无法更新这个值的话，这个值就是最新值
		- 因为有可能你读取的时候还是相对新的，但是在用之前，有个线程跑过来更新了，那你使用的时候还不是最新值
	- 单处理器也有可见性问题，因为多线程的时候，在上下文切换的时候，一个线程对这个变量的修改会被当做上下文存到寄存器上，导致别的现场无法看到这个修改
	- 可见性和原子性的联系和区别
		- 原子性保证的是，读取到的要么是相对新值，要么是初始值，而不会是一个不存在的值
		- 可见性，一个线程对共享变量的更新对于别的线程也能看到
	- 线程的启动，停止与可见性
		- 父线程在子线程启动前对共享变量的修改，对子线程可见
		- 一个线程终止后，该线程对共享变量的更新，对于调用其join方法的线程是可见的
- 有序性
	- 是对内存访问有关的操作（读，写）的一种优化，在不影响单线程程序正确性的情况下提升程序性能
	- 定义
		- 源代码顺序 代码里指定的内存访问操作顺序
		- 程序顺序 给定处理器上运行的目标代码所指定的内存访问操作顺序
		- 执行顺序 实际执行的顺序
		- 感知顺序 给定处理器感知到的该处理器及其他处理器的内存访问操作发生的顺序
		- 前三种是执行重排序，是真的改动指令的排序了的，最后一种是存储子系统重排序，发生在高速缓存写缓冲器，是读取的时候导致的重排序，执行顺序是没变的
	- 指令重排序
		- java有两种编译器，静态编译器，将java文件编译成class文件，动态编译器，翻译成宿主机的本地代码机器码
		- 处理器的执行重排序，导致执行顺序和程序顺序不一致，他的流程是
			- 会按照程序顺序进行顺序读取，但是为了提高效率，哪个指令就绪了就先执行这条语句，进行乱序执行，指令执行的结果会放到重排序缓冲器中，等所有指令执行完了之后，会按照程序顺序，提交到寄存器或内存中去
		- 处理器的乱序还体现在，猜测执行，比如if语句里的条件还没有达到，先去执行if里的语句，如果条件被证实不满足，就把语句里的结论删掉
	- 存储子系统重排序
		- 读内存操作是从RAM地址上加载数据到寄存器，Load
		- 写内存操作从寄存器中存储到RAM中，Store
	- 貌似串行语义
		- 在单线程下，保证不会出现错误，不影响正确性
		- 存在数据依赖关系的不会重排序，如写后读，读后写，写后写
		- 存在控制依赖关系的是可以重排序的，如 check then act，因为如果不能重排序会影响处理器对指令序列执行的并行程度
		- 单处理系统是否会收到重排序的影响
			- 编译器的话会
			- 运行期的话，不会。重排序发生的时候，相关指令还没有完全执行完毕，执行结果还没有到主内存，在只有一个处理器的情况下，通常不会进行上下文切换，所以不会有影响
	- 内存访问的顺序性
		- volatile，synchronized关键字
- 上下文切换
	- 时间片流转的时候，要把之前那个线程的相关信息存储起来，然后切入下一个线程，再切入的时候，读取之前存储的信息，继续运行
	- 一般包括寄存器的内容和程序计数器的内容
	- 自发性上下文切换
		- sleep
		- wait
		- yield
		- join
		- park
	- 非自发性上下文切换
		- 时间片用完了
		- 资源缺失
		- 有优先级更高的
		- GC的时候要求stop the world
	- 开销
		- 直接开销
			- 操作系统保存和恢复上下文
			- 线程调度器进行线程调度的开销
		- 间接开销
			- 处理器高速缓存重新加载开销
			- 整个一级高速缓存的内容被冲刷，内容会被写到下一级告诉缓存或主内存中
- 活性故障
	- 死锁
	- 活锁
	- 锁死  资源已经没了，还在等
	- 饥饿 有资源，但是轮不到自己
- 资源争用与调度
	- 如果资源一次性只能被一个线程占用，就叫排他性资源，回到值资源争用
	- 在多个线程申请同一个排他性资源的时候，会有个队列，没有争用到的就在这个等待队列里排队，等待队列里的线程会被暂停。申请到了，从队列移除，否则，还会放到队列里，再次被暂停
	- 非公平调度的话，突然来了个未入队的线程，他有资格争夺这个资源，这个就是赌，可能他的执行时间很短，他都已经用完了，队首的才重新唤醒起来，这样不会影响他，还提高了吞吐量，但是也有可能导致队内的线程造成饥饿现象
	- 公平调度的话，就是所有的都来排队，永远是队首的拿到资源，这种的话，吞吐量低，适合资源持有线程时间长，资源平均申请时间长的情况，或者对资源申请所需时间偏差不能太长的情况使用