tags:: 常用关键字，java

- transient
	- Java语言的关键字，变量修饰符
	- 如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。
	- 这里的对象存储是指，Java的serialization提供的一种持久化对象实例的机制。
	- 当一个对象被序列化的时候，transient型变量的值不包括在序列化的表示中，然而非transient型的变量是被包括进去的。
	- 使用情况是：当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。
	- 就是被transient修饰的成员变量，在序列化的时候其值会被忽略，在被反序列化后， transient 变量的值被设为初始值， 如 int 型的是 0，对象型的是 null。
- instanceof
	- instanceof 是 Java 的一个二元操作符，类似于 ==，>，< 等操作符。
	- 它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。
- volatile
	- `volatile`是一个变量修饰符，只能用来修饰变量。无法修饰方法及代码块等。
	- 只需要在声明一个可能被多线程同时访问的变量时，使用`volatile`修饰就可以了。
	- 原理
		- volatile变量进行写操作的时候，jvm向处理器发送一条lock前缀指令，将这个缓存变量会写到系统主存中
		- 如果一个变量被`volatile`所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个`volatile`在并发编程中，其值在多个缓存中是可见的。
	- 可见性
		- 多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值
	- 有序性
		- 规定不能指令重排序
	- 原子性
		- 不能保证原子性
	- 以下两个场景中可以使用`volatile`来代替`synchronized`：
		- 1、运算结果并不依赖变量的当前值，或者能够确保只有单一的线程会修改变量的值。
		- 2、变量不需要与其他状态变量共同参与不变约束。
- synchronzied
	- 用法
		- 可以修饰方法
		- 也可以修饰代码块
	- 实现原理
		- 为了保证同一个时间，这个资源只能被一个线程访问到，用sychronized关键字对类或对象加锁
		- 同步方法，JVM采用`ACC_SYNCHRONIZED`标记符来实现同步。
			- 方法的同步是隐式的，线程访问方法的时候，检查是否有`ACC_SYNCHRONIZED`标记，如果有，先获取监视器锁，然后执行方法，方法执行完进行释放。异常了，异常被抛到方法外面之前，监视器锁就会被自动释放
		- 同步代码块，JVM采用`monitorenter`、`monitorexit`两个指令来实现同步。
			- 每个对象维护记录锁次数的计数器。
			- 计数器为0的时候，锁被释放，其他线程可以获得锁。
	- 原子性
		- 因为在monitorenter和monitorexit指令中间，只能有一个线程访问，所以是原子性的
	- 可见性
		- 对一个变量解锁之前，必须先把此变量同步回主存中。这样解锁后，后续线程就可以访问到被修改后的值。
	- 有序性
		- 虽然没有办法禁止指令重排和处理器优化。
		- 但是重排序遵循 as-if-serial语义，在单线程里执行结果不能被改变。
		- 所以也能保证有序性
	- 锁优化
		- 轻量级锁
		- 偏向锁
		- 自旋锁
		- 锁消除
		- 适应性自旋锁
		- 锁粗化
- final
	- 修饰类
		- 类不能被继承
	- 修饰方法
		- 方法不能被重写
	- 修饰变量
		- 变量是个常量，一般和static一起用，不能改变
- static
	- 静态
	- 修饰变量
		- 是属于类的，不属于某个实例或类对象
	- 修饰方法
		- 静态方法里可能用静态变量和调用静态方法
	- 静态方法快
		- 是一组指令在类装载的时候在内存中由Java ClassLoader执行。
		- 静态块常用于初始化类的静态变量。大多时候还用于在类装载时候创建静态资源。
-
-
-
-