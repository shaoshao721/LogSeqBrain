tags:: 设计模式

- 分类：
	- 创建型模式
		- 单例模式
		- 原型模式
		- 工厂方法模式
		- 抽象工厂模式
		- 建造者模式
	- 结构型模式
		- 代理模式
		- 适配器模式
		- 桥接模式
		- 装饰模式
		- 外观模式
		- 享元模式
		- 组合模式
		- 过滤器模式
	- 行为型模式
		- 模版方法模式
		- 策略模式
		- 命令模式
		- 责任链模式
		- 状态模式
		- 观察者模式
		- 中介者模式
		- 迭代器模式
		- 访问者模式
		- 备忘录模式
		- 解释器模式
- 设计模式原则
	- 对接口编程而不是实现编程
	- 优先使用对象组合而不是继承
- 设计模式的基石
	- 封装
	- 继承
	- 多态
	- 顺序
	- 判断
	- 循环
- 组件的生命周期
	- ![image.png](../assets/image_1680102777227_0.png)
	- 组件定义的时候用结构型模式
	- 组件定义完了，要创建一个组件的对象，用创建型模式
	- 方法调用，使用的时候，用行为型模式
- 设计模式的7大原则
	- 开闭原则
		- 软件实体对扩展开放，对修改关闭
		- 扩展新类而不是修改旧类
		- A1不太适用了，可以扩展出来一个A2来适配当前的环境，而不是在A1中修改
	- 里氏替换原则
		- 继承必须保证超类拥有的性质在子类中仍然成立
		- 继承父类而不去改变父类
		- 不要去重写父类的方法而是应该去改变一些父类让我们去扩展的方法
		- 保证子类和父类是可以互相替换的
	- 依赖倒置原则
		- 高层模块不应该依赖底层模块，两者都应该依赖抽象。抽象不应该依赖细节，细节应该依赖抽象
		- 面向接口编程，而不是面向实现类
	- 单一职责原则
		- 一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分
		- 每个类只负责自己的事情，而不是变成万能
		- 这个负责链接数据库，那个负责增删改查，这种粒度的
	- 接口隔离原则
		- 一个类对另一个类的依赖应该建立在最小的接口上
		- 各个类建立自己的专用接口，而不是建立万能接口
	- 迪米特法则，最少知识原则
		- 无需直接交互的两个类，如果需要交互，用中间者
		- 可能会导致产生大量中介类，增加系统复杂度，使模块之间的通信效率降低
	- 合成复用原则
		- 优先组合，其次继承
- 创建型模式
	- 为什么要用创建型模式
		- 怎么创建对象
			- 将对象的创建和使用分离
			- 降低系统的耦合度
			- 不需要关注对象的创建细节
				- 对象的创建让工厂来完成 工厂模式
				- 让建造者来完成 建造者模式
				- 创建由原来对象克隆完成 原型模式
				- 保证对象在系统里只有一个实例 单例模式
- 结构型模式
	- 为什么要用结构型模式
		- **结构型模式**关注点“怎样组合对象/类？”所以我们关注下类的组合关系
		- **类结构型模式**关心类的组合，由多个类可以组合成一个更大的（继承）
		- **对象结构型模式**关心类与对象的组合，通过关联关系在一个类中定义另一个类的实例对象（组合）
		- 根据“**合成复用原则**”，在系统中尽量**使用关联关系来替代继承关系**，因此大部分结构型模式都是对象结构型模式。
			- 适配器模式（Adapter Pattern）：两个不兼容接口之间适配的桥梁
			- 桥接模式（Bridge Pattern）：相同功能抽象化与实现化解耦，抽象与实现可以独立升级。
			- 过滤器模式（Filter、Criteria Pattern）：使用不同的标准来过滤一组对象
			- 组合模式（Composite Pattern）：相似对象进行组合，形成树形结构
			- 装饰器模式（Decorator Pattern）：向一个现有的对象添加新的功能，同时又不改变其结构
			- 外观模式（Facade Pattern）：向现有的系统添加一个接口，客户端访问此接口来隐藏系统的复杂性。
			- 享元模式（Flyweight Pattern）：尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象
			- 代理模式（Proxy Pattern）：一个类代表另一个类的功能
- 行为型模式
	- 模版方法模式
	- 策略模式
	- 状态模式
	- 中介者模式
	- 观察者模式
	- 备忘录模式
	- 解释器模式
	- 命令模式
	- 迭代器模式
	- 访问者模式
	- 责任链模式
	- 行为型模式关注点“怎样运行对象/类？”所以我们关注下类/对象的运行时流程控制
	- 行为型模式用于描述程序在运行时复杂的流程控制，
	- 描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。
	- 行为型模式分为**类行为模式**和**对象行为模式**，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。
	- 具体
		- 模板方法（Template Method）模式：父类定义算法骨架，某些实现放在子类
		- 策略（Strategy）模式：每种算法独立封装，根据不同情况使用不同算法策略
		- 状态（State）模式：每种状态独立封装，不同状态内部封装了不同行为
		- 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开
		- 职责链（Chain of Responsibility）模式：所有处理者封装为链式结构，依次调用
		- 备忘录（Memento）模式：把核心信息抽取出来，可以进行保存
		- 解释器（Interpreter）模式：定义语法解析规则
		- 观察者（Observer）模式：维护多个观察者依赖，状态变化通知所有观察者
		- 中介者（Mediator）模式：取消类/对象的直接调用关系，使用中介者维护
		- 迭代器（Iterator）模式：定义集合数据的遍历规则
		- 访问者（Visitor）模式：分离对象结构，与元素的执行算法